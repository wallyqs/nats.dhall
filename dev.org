# -*- mode: org; mode: auto-fill -*- 
#+TODO:     ONIT HOLD PAUSED TODO | DONE CANCELED
#+TITLE:    nats.dhall
#+property: :header-args: :results output code :mkdirp true

A [[https://dhall-lang.org/][Dhall]] package to configure [[https://nats.io][NATS]].

* COMMENT Dev Setup

Setting up the prelude both for Emacs and local development.

#+BEGIN_SRC emacs-lisp
(setenv "NATS_PRELUDE" (concat default-directory "package.dhall"))
(setq dhall-command "/usr/local/bin/dhall")
(setq dhall-format-at-save nil)
#+END_SRC

#+BEGIN_SRC sh :tangle .env
export NATS_PRELUDE=$(pwd)/package.dhall
#+END_SRC

* NATS.dhall

** NATS Package

Include the types for the NATS Server and its Config format.

#+BEGIN_SRC dhall :tangle package.dhall
{
  , Server = ./server/package.dhall
  , Conf = ./conf/package.dhall
--  , K8S = ./k8s/package.dhall
}
#+END_SRC

** NATS.Conf

Includes the =NATS.Conf= format types and =NATS.Conf/render=.

** NATS.Server

*** Package

#+BEGIN_SRC dhall :tangle server/package.dhall
{
  , toConf = ./toConf.dhall
  , Config = ./config.dhall
  , ClusterConfig = ./config/cluster.dhall
  , LoggingConfig = ./config/logging.dhall
}
#+END_SRC

*** Types

**** TODO NATS.Server.Config

#+BEGIN_SRC dhall :tangle server/config.dhall
let ClusterConfig = ./config/cluster.dhall
let LoggingConfig = ./config/logging.dhall

let Config
    : Type
    = { 
        , host : Text
        , port : Natural
        , cluster : Optional ClusterConfig.Type
        , logging : Optional LoggingConfig.Type
      }

let default =
      { 
        , host = "0.0.0.0"
        , port = 4222
        , cluster = None ClusterConfig.Type
        , logging = None LoggingConfig.Type
      }

in  { default = default, Type = Config }
#+END_SRC

**** TODO NATS.Server.LoggingConfig

#+BEGIN_SRC dhall :tangle server/config/logging.dhall
let LoggingConfig
    : Type
    = { 
        , debug : Bool
        , trace : Bool
        , logtime : Optional Bool
      }

let default =
      { , debug = False
        , trace = False
        , logtime = None Bool
      }

in { default = default, Type = LoggingConfig }
#+END_SRC

**** TODO NATS.Server.ClusterConfig

https://github.com/nats-io/nats-server/blob/c25e8d4bbe4ec231885ee2778a6945c7f4d945bb/server/opts.go#L959

#+BEGIN_SRC dhall :tangle server/config/cluster.dhall
let ClusterConfig
    : Type
    = { 
        , host : Text
        , port : Natural
        , routes : List Text
        , clusterAdvertise : Text
        , noAdvertise : Bool
      }

let default =
      { , host = "0.0.0.0"
        , port = 6222
        , routes = [] : List Text
        , clusterAdvertise = ""
        , noAdvertise = False
      }

in { default = default, Type = ClusterConfig }
#+END_SRC

**** TODO NATS.Server.TLSConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L2876

#+BEGIN_SRC dhall :tangle server/config/tlsConfig.dhall
#+END_SRC

**** TODO NATS.Server.AuthorizationConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L2448

#+BEGIN_SRC dhall :tangle server/config/authorization.dhall
#+END_SRC


****** TODO NATS.Server.UserConfig
****** TODO NATS.Server.PermissionsConfig

#+BEGIN_SRC dhall :tangle server/config/permissions.dhall
#+END_SRC

**** TODO NATS.Server.AccountsConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L1731

****** TODO NATS.Server.ServiceImportConfig || NATS.Server.StreamImportConfig

https://github.com/nats-io/nats-server/blob/c25e8d4bbe4ec231885ee2778a6945c7f4d945bb/server/opts.go#L2013

****** TODO NATS.Server.ServiceExportConfig || NATS.Server.StreamExportConfig
**** TODO NATS.Server.WebsocketConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L2981

#+BEGIN_SRC dhall :tangle server/config/websocket.dhall
#+END_SRC

**** TODO NATS.Server.GatewayConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L1098

****** TODO NATS.Server.RemoteGatewayConfig
**** TODO NATS.Server.LeafnodeConfig

https://github.com/nats-io/nats-server/blob/master/server/opts.go#L1300

****** TODO NATS.Server.RemoteLeafnodeConfig
**** TODO NATS.Server.JetstreamConfig

https://github.com/nats-io/nats-server/blob/c25e8d4bbe4ec231885ee2778a6945c7f4d945bb/server/opts.go#L1250

*** Function

**** toConf

#+BEGIN_SRC dhall :tangle server/toConf.dhall 
let Natural/equal =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/Natural/equal

let List/concat =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/List/concat

let List/map =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/List/map

let Natural/enumerate =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/Natural/enumerate

let Config = ./config.dhall
let ClusterConfig = ./config/cluster.dhall
let LoggingConfig = ./config/logging.dhall

let NATS/Cluster = ./cluster.dhall

let NATS/Conf = ../conf/package.dhall

let toConf =
    {- toConf takes a NATS Server Config and generates the NATS/Conf type object
       that can be rendered
    -}
        λ(nats : Config.Type)
      → let port = Natural/toInteger nats.port

        -- Initialize empty config
        let empty = [ ] : List { mapKey : Text, mapValue : NATS/Conf.Type }

        -- Add the port, work with records that can be merged
        let clientConf = toMap {
          port = NATS/Conf.integer port
        }

        -- merge is like a 'match' pattern matching
        let clusterConf = merge 
        {
          , Some = \(cluster : ClusterConfig.Type) -> (toMap {
            , cluster = NATS/Conf.object (toMap { 
                , port = NATS/Conf.integer (Natural/toInteger cluster.port)
              })
            })
          , None = empty
        } nats.cluster

        let loggingConf = merge 
        {
          , Some = \(logging : LoggingConfig.Type) -> (toMap {
              , debug = NATS/Conf.bool logging.debug
              , trace = NATS/Conf.bool logging.trace
            })
          , None = empty
        } nats.logging

        let conf = List/concat { mapKey : Text, mapValue : NATS/Conf.Type } [ 
           clientConf, clusterConf, loggingConf
        ]

        -- This is not what we want
        -- let result = NATS/Conf.object conf
        -- in NATS/Conf.render result

        -- At the end return the list of 
        in NATS/Conf.object conf
in  toConf
#+END_SRC


** COMMENT Prev: =NATS.Server.Cluster= and =toConf=
*** COMMENT Cluster

#+BEGIN_SRC dhall :tangle server/cluster.dhall
let Cluster
    : Type
    = { name : Text
      , namespace : Text
      , image : Text
      , externalAccess : Bool
      , size : Natural
      , clientPort : Natural
      , clusterPort : Natural
      , leafnodePort : Natural
      , gatewayPort : Natural
      , monitoringPort : Natural
      }

let defaultCluster =
      { name = None Text
      , namespace = "default"
      , image = "nats:latest"
      , externalAccess = False
      , size = 1
      , clientPort = 4222
      , clusterPort = 6222
      , leafnodePort = 7422
      , gatewayPort = 7522
      , monitoringPort = 8222
      }

in  { default = defaultCluster, Type = Cluster }
#+END_SRC

*** COMMENT toConf

#+BEGIN_SRC dhall :tangle server/toConf.dhall 
let Natural/equal =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/Natural/equal

let List/concat =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/List/concat

let List/map =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/List/map

let Natural/enumerate =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v16.0.0/Prelude/Natural/enumerate

let NATS/Cluster = ./cluster.dhall

let NATS/Conf = ../conf/package.dhall

let toConf =
    {- toConf takes a NATS/Cluster and generates the NATS Server configuration
       that can be stored in ConfigMap.
    -}
        λ(nats : NATS/Cluster.Type)
      → let name = nats.name
        let namespace = nats.name
        let client = {
          , port = Natural/toInteger nats.clientPort
        }
        let monitoring = {
          , port = Natural/toInteger nats.monitoringPort
        }
        
        let serverConf = toMap {
          , port = NATS/Conf.integer client.port
          , http = NATS/Conf.integer monitoring.port
          , server_name = NATS/Conf.envValue "$POD_NAME"
        }

        let cluster = {
          , port = Natural/toInteger nats.clusterPort
          , host = "0.0.0.0"
        }

        -- Generate list of integers
        let routes = if Natural/equal nats.size 1
            then [ ] : List NATS/Conf.Type
            else
              -- Generate a couple of lists then map them together
              let servers = Natural/enumerate nats.size
              let apply : Natural -> NATS/Conf.Type =
                  λ(i : Natural)
                  -> let n = Natural/show i
                     in NATS/Conf.string "nats://${name}-${n}.${name}.${namespace}.svc:${Natural/show nats.clusterPort}"

              let entries = List/map Natural NATS/Conf.Type apply servers
              -- in [
              --      NATS/Conf.string "nats://${name}-0.${name}.${namespace}.svc:${Natural/show nats.clusterPort}",
              --      NATS/Conf.string "nats://${name}-1.${name}.${namespace}.svc:${Natural/show nats.clusterPort}",
              --      NATS/Conf.string "nats://${name}-2.${name}.${namespace}.svc:${Natural/show nats.clusterPort}"
              -- ]
              in entries

        -- Merge in the routes
        let cluster = cluster ∧ { routes = routes }

        let clusterConf = if Natural/equal nats.size 1
        -- Note: Empty list requires type annotation
        then [ ] : List { mapKey : Text, mapValue : NATS/Conf.Type }
        else [
          , { mapKey = "cluster", mapValue = NATS/Conf.object [
               , { mapKey = "port", mapValue = NATS/Conf.integer cluster.port }
               , { mapKey = "routes", mapValue = NATS/Conf.array 
                   [ NATS/Conf.array routes ] 
                 }
             ]
          }
        ]

        let merged = List/concat { mapKey : Text, mapValue : NATS/Conf.Type } [
          serverConf, clusterConf
        ]

        let conf = NATS/Conf.object merged
        in NATS/Conf.render conf

in  toConf
#+END_SRC

** COMMENT NATS.K8S

*** Package

#+BEGIN_SRC dhall :tangle k8s/package.dhall 
{
  , toK8S = ./toK8S.dhall
  , toList = ./toList.dhall
}
#+END_SRC

*** Types

**** NATS.K8S.Cluster

#+BEGIN_SRC dhall :tangle k8s/cluster.dhall
let kubernetes =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/package.dhall sha256:d9eac5668d5ed9cb3364c0a39721d4694e4247dad16d8a82827e4619ee1d6188

let Cluster
    : Type
    = { StatefulSet : kubernetes.StatefulSet.Type
      , ConfigMap : kubernetes.ConfigMap.Type
      , Service : kubernetes.Service.Type
      }

let defaultCluster =
      { StatefulSet = kubernetes.StatefulSet.Type
      , ConfigMap = kubernetes.ConfigMap.Type
      , Service = kubernetes.Service.Type
      }

in  { default = defaultCluster, Type = Cluster }
#+END_SRC

*** Functions

**** toK8S

#+BEGIN_SRC dhall :tangle k8s/toK8S.dhall
let kubernetes =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/package.dhall sha256:d9eac5668d5ed9cb3364c0a39721d4694e4247dad16d8a82827e4619ee1d6188

let NATS/toConf = ../server/toConf.dhall

let NATS/Cluster = ../server/cluster.dhall

let NATS/K8S/Cluster = ./cluster.dhall

let toK8S =
        λ(nats : NATS/Cluster.Type)
      → let labels = Some (toMap { app = nats.name })

        let metadata =
              kubernetes.ObjectMeta::{ name = nats.name, labels = labels, namespace = Some nats.namespace }

        let cmMetadata =
              kubernetes.ObjectMeta::{
              , name = "${nats.name}-config"
              , labels = labels
	      , namespace = Some nats.namespace
              }

        let clientHostPort =
              if nats.externalAccess then Some nats.clientPort else None Natural

        let clientPort =
              kubernetes.ContainerPort::{
              , containerPort = nats.clientPort
              , name = Some nats.name
              , hostPort = clientHostPort
              }

        let natsConfFile = "nats.conf"

        let serverConfig = NATS/toConf nats

        let configVolume =
              kubernetes.Volume::{
              , name = "config-volume"
              , configMap = Some kubernetes.ConfigMapVolumeSource::{
                , name = Some cmMetadata.name
                }
              }

        let configVolMount =
              kubernetes.VolumeMount::{
              , name = configVolume.name
              , mountPath = "/etc/nats"
              }

        let command =
              [ "/nats-server"
              , "-c"
              , "${configVolMount.mountPath}/${natsConfFile}"
              ]

        let natsContainer =
              kubernetes.Container::{
              , name = "nats"
              , image = Some nats.image
              , ports = Some [ clientPort ]
              , command = Some command
              , volumeMounts = Some [ configVolMount ]
              }

        let cm =
              kubernetes.ConfigMap::{
              , metadata = cmMetadata
              , data = Some
                [ { mapKey = natsConfFile, mapValue = serverConfig } ]
              }

        let sts =
              kubernetes.StatefulSet::{
              , metadata = metadata
              , spec = Some kubernetes.StatefulSetSpec::{
                , serviceName = nats.name
                , selector = kubernetes.LabelSelector::{ matchLabels = labels }
                , replicas = Some nats.size
                , template = kubernetes.PodTemplateSpec::{
                  , metadata = metadata
                  , spec = Some kubernetes.PodSpec::{
                    , containers = [ natsContainer ]
                    , volumes = Some [ configVolume ]
                    }
                  }
                }
              }

        let svc =
              kubernetes.Service::{
              , metadata = metadata
              , spec = Some kubernetes.ServiceSpec::{
                , selector = labels
                , clusterIP = Some "None"
                , ports = Some
                  [ kubernetes.ServicePort::{
                    , name = Some "client"
                    , port = nats.clientPort
                    , targetPort = Some
                        (kubernetes.IntOrString.Int nats.clientPort)
                    }
                  ]
                }
              }

        in  NATS/K8S/Cluster::{
            , StatefulSet = sts
            , ConfigMap = cm
            , Service = svc
            }

in  toK8S
#+END_SRC

**** toList

#+BEGIN_SRC dhall :tangle k8s/toList.dhall
let kind =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/typesUnion.dhall sha256:61d9d79f8de701e9442a796f35cf1761a33c9d60e0dadb09f882c9eb60978323

let NATS/K8S/Cluster = ./cluster.dhall

let toList =
        λ(nats : NATS/K8S/Cluster.Type)
      → { apiVersion = "v1"
        , kind = "List"
        , items =
          [ kind.StatefulSet nats.StatefulSet
          , kind.ConfigMap nats.ConfigMap
          , kind.Service nats.Service
          ]
        }

in  toList
#+END_SRC



