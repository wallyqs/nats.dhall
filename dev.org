# -*- mode: org; mode: auto-fill -*- 
#+TODO:     ONIT HOLD PAUSED TODO | DONE CANCELED
#+TITLE:    nats.dhall
#+property: :header-args: :results output code :mkdirp true

A [[https://dhall-lang.org/][Dhall]] package to work with [[https://nats.io][NATS]] configuration objects.

* COMMENT Dev Setup

Setting up the prelude both for Emacs and local development.

#+BEGIN_SRC emacs-lisp
(setenv "NATS_PRELUDE" (concat default-directory "package.dhall"))
(setq dhall-command "/usr/local/bin/dhall")
#+END_SRC

#+BEGIN_SRC sh :tangle .env
export NATS_PRELUDE=$(pwd)/package.dhall
#+END_SRC

* =nats.dhall= package

** NATS Package

#+BEGIN_SRC dhall :tangle package.dhall
{
  , Server = ./server/package.dhall
  , K8S = ./k8s/package.dhall
}
#+END_SRC

** NATS.Server

*** Package

#+BEGIN_SRC dhall :tangle server/package.dhall
{
  , Cluster = ./cluster/schemas.dhall
  , toConf = ./toConf.dhall
}
#+END_SRC

*** Schemas

#+BEGIN_SRC dhall :tangle server/cluster/schemas.dhall
{
  , Type = ./type.dhall
  , default = ./default.dhall
}
#+END_SRC

*** Cluster:Type

#+BEGIN_SRC dhall :tangle server/cluster/type.dhall
let Cluster : Type = {
  , name : Text
  , namespace : Text
  , image : Text
  , externalAccess : Bool
  , size : Natural

  -- FIXME: Move this into its own type.
  , clientPort : Natural
  , clusterPort : Natural
  , leafnodePort : Natural
  , gatewayPort : Natural
  , monitoringPort : Natural
}

in Cluster
#+END_SRC

*** Cluster:Defaults

#+BEGIN_SRC dhall :tangle server/cluster/default.dhall
{ name = None Text
, namespace = "default"
, image = "nats:latest"
, externalAccess = False
, size = 1
, clientPort = 4222
, clusterPort = 6222
, leafnodePort = 7422
, gatewayPort = 7522
, monitoringPort = 8222
}
#+END_SRC

*** toConf

#+BEGIN_SRC dhall :tangle server/toConf.dhall 
let Natural/equal =
      https://raw.githubusercontent.com/dhall-lang/dhall-lang/v15.0.0/Prelude/Natural/equal

let NATS/Cluster = ./cluster/type.dhall

let toConf =
    {- toConf takes a NATS cluster and generates a configuration map.
    TODO: Make a server conf package to represent in types.
    -}
        λ(nats : NATS/Cluster)
      → let clusterPort = Natural/show nats.clusterPort

        let routes =
                    if Natural/equal nats.size 1

              then  ""

              else  "nats://${nats.name}.${nats.namespace}.svc:${clusterPort}"

        in  ''
            port = ${Natural/show nats.clientPort}
            http = ${Natural/show nats.monitoringPort}

            cluster {
              port = ${Natural/show nats.clusterPort}
              routes = [
                ${routes}
              ]
            }
            ''

in  toConf
#+END_SRC

** NATS.K8S

*** Package

#+BEGIN_SRC dhall :tangle k8s/package.dhall 
{
  , toK8S = ./toK8S.dhall
  , toList = ./toList.dhall
}
#+END_SRC

*** NATS/K8S/Cluster

#+BEGIN_SRC dhall :tangle k8s/cluster.dhall
let kubernetes =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/package.dhall sha256:d9eac5668d5ed9cb3364c0a39721d4694e4247dad16d8a82827e4619ee1d6188

let Cluster
    : Type
    = { StatefulSet : kubernetes.StatefulSet.Type
      , ConfigMap : kubernetes.ConfigMap.Type
      , Service : kubernetes.Service.Type
      }

let defaultCluster =
      { StatefulSet = kubernetes.StatefulSet.Type
      , ConfigMap = kubernetes.ConfigMap.Type
      , Service = kubernetes.Service.Type
      }

in  { default = defaultCluster, Type = Cluster }
#+END_SRC

*** toK8S

#+BEGIN_SRC dhall :tangle k8s/toK8S.dhall
let kubernetes =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/package.dhall sha256:d9eac5668d5ed9cb3364c0a39721d4694e4247dad16d8a82827e4619ee1d6188

let NATS/toConf = ../server/toConf.dhall

let NATS/Cluster = ../server/cluster/type.dhall

let NATS/K8S/Cluster = ./cluster.dhall

let toK8S =
        λ(nats : NATS/Cluster)
      → let labels = Some (toMap { app = nats.name })

        let metadata =
              kubernetes.ObjectMeta::{ name = nats.name, labels = labels, namespace = Some nats.namespace }

        let cmMetadata =
              kubernetes.ObjectMeta::{
              , name = "${nats.name}-config"
              , labels = labels
	      , namespace = Some nats.namespace
              }

        let clientHostPort =
              if nats.externalAccess then Some nats.clientPort else None Natural

        let clientPort =
              kubernetes.ContainerPort::{
              , containerPort = nats.clientPort
              , name = Some nats.name
              , hostPort = clientHostPort
              }

        let natsConfFile = "nats.conf"

        let serverConfig = NATS/toConf nats

        let configVolume =
              kubernetes.Volume::{
              , name = "config-volume"
              , configMap = Some kubernetes.ConfigMapVolumeSource::{
                , name = Some cmMetadata.name
                }
              }

        let configVolMount =
              kubernetes.VolumeMount::{
              , name = configVolume.name
              , mountPath = "/etc/nats"
              }

        let command =
              [ "/nats-server"
              , "-c"
              , "${configVolMount.mountPath}/${natsConfFile}"
              ]

        let natsContainer =
              kubernetes.Container::{
              , name = "nats"
              , image = Some nats.image
              , ports = Some [ clientPort ]
              , command = Some command
              , volumeMounts = Some [ configVolMount ]
              }

        let cm =
              kubernetes.ConfigMap::{
              , metadata = cmMetadata
              , data = Some
                [ { mapKey = natsConfFile, mapValue = serverConfig } ]
              }

        let sts =
              kubernetes.StatefulSet::{
              , metadata = metadata
              , spec = Some kubernetes.StatefulSetSpec::{
                , serviceName = nats.name
                , selector = kubernetes.LabelSelector::{ matchLabels = labels }
                , replicas = Some nats.size
                , template = kubernetes.PodTemplateSpec::{
                  , metadata = metadata
                  , spec = Some kubernetes.PodSpec::{
                    , containers = [ natsContainer ]
                    , volumes = Some [ configVolume ]
                    }
                  }
                }
              }

        let svc =
              kubernetes.Service::{
              , metadata = metadata
              , spec = Some kubernetes.ServiceSpec::{
                , selector = labels
                , clusterIP = Some "None"
                , ports = Some
                  [ kubernetes.ServicePort::{
                    , name = Some "client"
                    , port = nats.clientPort
                    , targetPort = Some
                        (kubernetes.IntOrString.Int nats.clientPort)
                    }
                  ]
                }
              }

        in  NATS/K8S/Cluster::{
            , StatefulSet = sts
            , ConfigMap = cm
            , Service = svc
            }

in  toK8S
#+END_SRC

*** toList

#+BEGIN_SRC dhall :tangle k8s/toList.dhall
let kind =
      https://raw.githubusercontent.com/dhall-lang/dhall-kubernetes/v4.0.0/1.17/typesUnion.dhall sha256:61d9d79f8de701e9442a796f35cf1761a33c9d60e0dadb09f882c9eb60978323

let NATS/K8S/Cluster = ./cluster.dhall

let toList =
        λ(nats : NATS/K8S/Cluster.Type)
      → { apiVersion = "v1"
        , kind = "List"
        , items =
          [ kind.StatefulSet nats.StatefulSet
          , kind.ConfigMap nats.ConfigMap
          , kind.Service nats.Service
          ]
        }

in  toList
#+END_SRC
